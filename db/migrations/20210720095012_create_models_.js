
exports.up = function (knex) {
  const timingNow = knex.fn.now()
  return knex.schema
    .createTable('models', table => {
      table.increments('id').primary()
      table.string('name').unique()
      table.string('description')
      table.json('tags')
      table.json('fileList')
      table.json('classifyList')
      table.integer('workspaceId')
      table.integer('rootBlockId').nullable()
      table.foreign('rootBlockId').references('blocks.id').onDelete('SET NULL')
      table.foreign('workspaceId').references('workspaces.id').onDelete('CASCADE')
    })
    .createTable('blocks', table => {
      table.increments('id').primary()
      table.string('name') // should not be unique()
      table.timestamp('updatedAt').defaultTo(timingNow)
      table.timestamp('updatedFormulaAt').defaultTo(timingNow)
      table.timestamp('updatedHeaderAt').defaultTo(timingNow)
      table.timestamp('updatedPropertyAt').defaultTo(timingNow)
      table.string('description')
      table.json('tags')
      table.string('copyType')
      table.integer('copySize')
      table.string('groupSeparators')
      table.string('copySizeFunctionLines')
      table.string('rebaseNeeded')
      table.boolean('slidingWindow')
      table.string('runAfterRebaseFormula')
      table.string('rebaseBaseFunctionLines')
      table.string('initializeFormula')
      table.string('finalizeFormula')
      table.string('definitions')
      table.boolean('share')
      table.boolean('static')
      table.json('variables')
      table.json('series')
      table.json('links')
      table.json('methods')
      table.integer('productId')
      table.integer('parentId')
      table.foreign('parentId').references('blocks.id').onDelete('CASCADE')
      table.integer('modelId')
      table.foreign('modelId').references('models.id').onDelete('CASCADE')
      table.integer('workspaceId')
      table.foreign('workspaceId').references('workspaces.id').onDelete('CASCADE')
    })
    .createTable('targets', table => {
      table.increments('id').primary()
      table.string('name') // .unique()
      table.json('linkChain')
      table.integer('modelId')
      table.foreign('modelId').references('models.id').onDelete('CASCADE')
      table.integer('workspaceId')
      table.foreign('workspaceId').references('workspaces.id').onDelete('CASCADE')
      table.json('variablesAndSeries')
    })
    .createTable('outputs', table => {
      table.increments('id').primary()
      table.string('name') // .unique()
      table.json('linkChain')
      table.integer('modelId')
      table.foreign('modelId').references('models.id').onDelete('CASCADE')
      table.integer('workspaceId')
      table.foreign('workspaceId').references('workspaces.id').onDelete('CASCADE')
      table.json('series')
      table.integer('periodFrom')
      table.integer('periodTo')
      table.boolean('blockCopy')
      table.boolean('blockDepth')
      table.boolean('seriesCopy')
      table.boolean('seriesDepth')
      table.boolean('separateSeriesCopyPage')
      table.boolean('fileSeparateByCopy')
      table.boolean('fileSeparateByNode')
      table.boolean('fileSeparateByDepth')
      table.boolean('outputAllLevels')
      table.integer('blockCopyMinLevel')
      table.integer('blockCopyMaxLevel')
    })
    .createTable('runners', table => {
      table.increments('id').primary()
      table.string('name').unique()
      table.integer('modelId')
      table.foreign('modelId').references('models.id').onDelete('CASCADE')
      table.integer('workspaceId')
      table.foreign('workspaceId').references('workspaces.id').onDelete('CASCADE')
      table.integer('inputId')
      table.json('blockInputId')
      table.json('targets')
      table.json('outputs')
      table.json('groupSeparators')
      table.json('assumption')
    })
    .createTable('projections', table => {
      table.increments('id').primary()
      table.string('name').unique()
      table.string('description')
      table.integer('workspaceId')
      table.foreign('workspaceId').references('workspaces.id').onDelete('CASCADE')
      table.string('mode')
      table.json('runnerSelections')
      table.integer('calculationStackHeightLimit')
      table.integer('multiThreadNumber')
      table.integer('errorTraceLength')
      table.boolean('shareBlockResults')
      table.boolean('allowStaticBlocks')
      table.boolean('allowScope')
      table.integer('scopeFrom')
      table.integer('scopeTo')
      table.boolean('allowInnerLoopNumber')
      table.integer('innerLoopNumberFrom')
      table.integer('innerLoopNumberTo')
      table.boolean('allowOuterLoopNumber')
      table.integer('outerLoopNumberFrom')
      table.integer('outerLoopNumberTo')
      table.boolean('modelPointsOutput')
      table.boolean('independentInnerLoop')
      table.boolean('independentOuterLoop')
      table.string('outputFolder')
      table.string('outputPrefix')
      table.integer('outputPrecision')
      table.boolean('slidingWindow')
      table.boolean('rebaseDepth')
      table.boolean('rebaseSwitch')
      table.boolean('allowIterationWhenCircularReference')
    })
    .createTable('tasks', table => {
      table.increments('id').primary()
      table.string('taskName')
      table.string('outputAddress')
      table.integer('status')
      table.integer('submitTime')
      table.integer('projectionId')
      table.integer('completedTime')
      table.string('submitter')
      table.string('modelName')
      table.string('outputChildAddress')
      table.integer('modelId')
      table.integer('pid')
      table.string('processId')
      table.integer('workspaceId')
      table.foreign('workspaceId').references('workspaces.id').onDelete('CASCADE')
    })
}

exports.down = function (knex) {
  return knex.schema
    .dropTable('models')
    .dropTable('blocks')
    .dropTable('targets')
    .dropTable('outputs')
    .dropTable('runners')
    .dropTable('projections')
    .dropTable('tasks')
    .dropTable('products')
}
